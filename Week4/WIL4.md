WIL4 - 내용 정리

1장 사람을 사랑한 기술

어셈블리어 : 같은 일을 하는 프로그램의 소스파일을 각 기계의 종류만큼 만들어야함(multi object) = 멀티 소스
C언어 : 소스파일 단 하나면 충분 = 싱글 소스, m:n 매칭 가능

c++ -> 객체 지향(중심에는 class, 객체 object의 개념이 필요) 개념 도입. but, 객체 없는 프로그래밍도 가능

JAVA -> 클래스를 떠나 존재할 수 있는것 X. main 메서드도 클래스 내부에 존재해야함. 모든 메서드도 클래스.메서드명() or 객체.메서드명()으로 접근해야함 -가상머신이라는 개념이 있음(JVM), CLR(공통 언어 런타임), Write Once Use Anywhere(C언어 대비 글자수 많이 줄음), 컴파일러를 기종별로 따로 구매하지 않아도 됨 -구현한 소스 -> 다른 기종의 컴퓨터의 실행을 위해 목적 파일인 오브젝트 파일만 가져감 + JRE 설치(해당 기종용) -> 실행 O

UML : 의사소통 도구 = 표기 방법론. 액티비티 다이어그램 보다는 순서도, NS차트, 클래스 다이어그램, 시퀀스 다이어그램 등을 자주 그림

CBD (Component Based Development) : 컴포넌트 기반 개발. 애플리케이션을 의미있는 단위로 구분, 단위를 하나씩 부품으로 개발 (레고 블록 쌓아 올리듯 부품 결함) -> 소프트웨어 제품 완성하자는 방법론.(제품X)
SOA(Service Oriented Architecture) : 서비스 중심 구조(서비즈 지향 구조) 실제 현실의 업무를 기준으로 개발하자는 사상(제품X) => 본질을 잘 살펴서 취할것은 취하고 버릴것은 버리는 선별하는 능력 필요

스프링 프레임워크가 어려운 이유 : 스프링 프레임 워크가 무엇인지 개념을 명확히 알지 못함, 제품이 너무 방대함.
스프링 프레임워크 = OOP 프레임워크 개념

IoC/DI, AOP, PSA -> POJO에 세가지 유형의 진동 -> 거대한 프레임 워크 완성

스프링 프레임 워크의 장점 : 엔터라이즈 애플리케이션을 구현하는데 필요한 거의 모든 서비스 지원, PSA 기법을 통해 표준화된 방식으로 사용할 수 있도록 지원, 더 쉽고 편하며 안정적이게 엔터프라이즈 애플리케이션 개발이 가능함

OOP 개념, 자바 언어의 문법, 자바가 OOP 개념을 구현한 방식

2장 자바와 절차적/구조적 프로그래밍(학습을 위해서 자바 IDE인 이클립스 or 스트링 프레임워크에 최적화한 STS 필요)

자바 = 객체지향 언어, 프로그래밍 언어. 자바 개발도구인 JDK를 이용해 개발된 프로그램은 JRE(자바 실행 환경)에 의해 가상의 컴퓨터인 JVM에서 구동됨(JVM = Java Virtual Machine. 가상기계) JDE가 JRE포함, JRE가 JVM 포함
JDK - 자바 소스 컴파일러인 javac.exe 포함. JRE - 자바 프로그램 실행기 java.exe 포함 => 파일을 따로 준비해야했던 불편함 없앰. -> JVM용으로 프로그램 작성 및 배포 -> 플랫폼에 맞는 JVM이 중재자로서 각 플랫폼에서 프로그램 구동하는데 아무 문제 없게끔 만들어줌. => Write Once Run Anywhere

메모리의 데이터 저장 영역 -> T 메모리구조(3분할 구조)

객체지향 프로그래밍 - 절차적(goto를 쓰지 말라 -> 프로그램의 실행 순서 이해하기 어려움)/구조적 프로그램(함수 = 메서드를 쓰라! 지역변수를 써라!-> 중복 코드 한곳에 모아서 관리 O, 논리를 함수 단위로 분리해서 이해하기 쉬운 코드 작성 O, )의 어깨를 딛고 성장.

함수와 메서드 차이 : 함수는 클래스나 객체와 아무 관계X, 메서드는 클래스 정의 안에 반드시 존재해야함

JRE -> 프로그램 안에 main()메서드가 있는지 확인 -> JVM 전원을 넣어 부팅 -> 목적 파일을 받아서 실행 -> 전처리(java.lang 패키지, system.out.println()같은 메서드 쓸 수 O, import된 패키지 -> T 메모리의 스태틱 영역에 배치). -> 프로그램 상의 모든 클래스 T 메모리 스태틱 영역에 가져다 놓음

필수과제
순차적 프로그래밍 : 순차적으로 흘러가는 프로그래밍 구조. 코딩 - 코드의 흐름, 순서에 기반하는 프로그래밍 -> goto문을 사용해서 코드를 짜게 됨
절차적 프로그래밍 : 절차 = 프로시져(반환값이 없고 실행이 주가 되는 함수), 반복될 가능성이 있는 모듈 -> 재사용 가능한 프로시저 단위(함수단위)로 나눈 프로그래밍 ex. 중복되는 부분 -> for문 등의 반복문 구성 2. JVM은 Java Virtual Machine의 줄임말으로, 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행함. JVM은 JAVA와 OS사이에서 중재자 역할. OS에 구애받지 않고 독립적으로 작동이 가능하며, 메모기 관리 GC(garbage collection) 수행 가능.
GC=garbage collection : 자바의 메모리 관리 방법 중의 하나. JVM의 Heap 영역에서 동적으로 할당했던 메모리 영역 중 필요 없게 된 메모리 영역을 주기적으로 삭제하는 프로세스. 3. 힙(Heap) 영역 : 자바 프로그램에서 사용되는 모든 인스턴스 변수(객체)들이 저장되는 영역. new를 사용 -> 객체를 생성 -> 힙 영역에 저장. 메모리 공간이 동적으로 할당되고 해제됨. 메모리의 낮은 주소 -> 높은 주소로 할당
Method(Static) 영역 : JVM이 동작해서 클래스가 로딩될 때 생성. JVM이 읽어들인 클래스와 인터페이스 대한 런타임 상수 풀, 멤버 변수(필드), 클래스 변수(Static 변수), 상수(final), 생성자(constructor)와 메소드(method) 등을 저장. Method(Static) 영역에 있는 것은 어느곳에서나 접근 가능함.
Stack 영역 : 메소드 내에서 정의하는 기본 자료형에 해당되는 지역변수의 데이터 값이 저장되는 공간, 메소드가 호출될때 스택 영역에 스택 프레임이 생기고 그안에 메소드를 호출, primitive 타입의 데이터(int, double, byte, long, boolean 등) 에 해당되는 지역변수, 매개 변수 데이터 값이 저장, 메소드가 호출 될 때 메모리에 할당되고 종료되면 메모리에서 사라짐 4. 금형기계와 붕어빵틀이 클래스와 객체 관계가 아닌듯 붕어빵틀과 붕어빵도 클래스와 객체 관계가 아니다. 붕아쁭틀은 붕어빵을 만드는 팩터리(디자인 패턴에 나오는 팩터리 디자인). 클래스 = 분류에 대한 개념. 실체가 X. 객체 = 실체
