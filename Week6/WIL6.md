WIL6

필수 과제

1. 추상 클래스, 인터페이스 정리

<abstract = 추상 클래스>
'abstract' - 추상 메서드, 추상 클래스 -추상 메서드(abstract method) : 선언부는 있는데 구현부가 없는 메서드 -추상 클래스(Abstract Class) : 추상 메서드를 하나라도 갖고 있는 클래스, 추상 메서드 없이도 선언 가능
상위 클래스의 참조 변수를 통해 하위 클래스의 인스턴스가 가진 메소드를 호출한다면, 상위 클래스에도 해당 메서드가 반드시 존재해야한다(ex. 병아리 extends 동물 -> 병아리에 울어보세요() 메서드 존재 + 참조 변수를 동물 -> 동물 클래스에도 울어보세요() 메서드가 필요함) but, 상위 클래스의 인스턴스를 만들고 그렇게 만들어진 객체의 메서드를 호출하면 난감해짐 -> abstract method(추상 메서드) 사용 = 메서드 선언은 있으나 몸체는 없는 형태의 메서드
추상클래스는 인스턴스(객체)를 만들 수 없는 클래스임(변수 배열로 모든 하위 클래스 객체의 메서드를 사용하려면 하위 클래스에서 해당 메서드가 오버라이딩 되어야하는 것 해결+ 상위 클래스에서 객체가 잘못 만들어지는 것 해결+ 상위 클래스에서 메서드 구현의 어려움 해결)
추상 클래스 = 인스턴스(객체)를 만들 수 없음(new 사용X)
추상 메서드 = 하위 클래스에게 메서드 구현(오버라이딩)을 강제
추상 메서드 포함하는 클래스 = 반드시 추상 클래스

생성자 = 클래스의 인스턴스(객체)를 만들때 'new' 사용 = 객체 생성자 메서드
ex) new 클래스명() -> 클래스명()도 메서드임. 반환값 X, 클래스명과 같은 이름을 가진 메서드 객체 생성하는 메서드 = 객체 생성자 메서드 = 생성자
클래스에 아무런 메서드가 없는 것처럼 보여도 아무런 인자도 갖지 않은 기본 생성자 메서드가 존재(자바 컴파일러가 알아서 기본 생성자 만들어줌)
개발자가 아무런 생성자도 만들지 않으면 자바가 인자 없는 기본 생성자를 자동으로 만들어줌 but, 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성자를 만들어주지 않음

<interface>
interface - public 추상 메서드(몸체가 없는 메서드)와 public 정적 상수만 가질 수 O. 따로 메서드에 public, abstract, 속성에 public과 static, final을 붙이지 않아도 자동으로 자바에서 붙여줌(final static 등)

변수 - 값 저장 O, 메서드의 인자로 쓰일 수 O , 메서드의 반환 값으로 사용될 수 O -> 람다로 인해 변수에 로직 저장, 로직을 메서드의 인자로, 로직을 메서드의 반환 값으로 사용 O(함수형 언어의 특성 수용)

interface = 일종의 추상 클래스 = 추상 메서드와 상수만을 멤버로 가질 수 O(추상 클래스처럼 추상 메서드를 갖지만, 추상화 정도가 높아서 일반 메서드, 멤버 변수를 구성원으로 가질 수 X) -> 다른 클래스를 작성하는데 도움을 줌

키워드를 class 대신 interface를 사용(접근 제어자 사용 O).
단, 모든 멤버 변수는 public static fainal(생략O), 모든 메서드는 public abstract(생략 O)이어야함 -> implements 키워드를 사용함(인터페이스를 구현)

구현하는 인터페이스의 메서드 중 일부만 구현 -> abstract를 부여서 추상 클래스로 선언해야함

상속과 구현을 동시에 할 수 O

인터페이스는 인터페이스로부터만 상속을 받을 수 O, 다중 상속 O, Object 같은 최고 조상 X

인터페이스 자체로 인스턴스 생성 X -> 추상 메서드의 몸통을 만들어주는 클래스 작성해야함

인터페이스 타입의 참조변수로 구현한 클래스의 인스턴스 참조 O + 인터페이스 타입으로 형 변환 O -> 매개변수 타입으로도 사용될 수 O, 리턴 타입으로도 사용될 수 O(메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환함)

2. static, final, 불변 객체 정리
   <static>
   -Static 블록 (클래스 생성 시의 실행 블록) = 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록 (클래스 안에 static{ '내용' } -> 클래스 생성 시 블록이 실행됨) -> 클래스를 사용하는 코드가 없으면 static 블록 실행 X, 클래스는 T 메모리 스태틱 영역에 자리 잡지도 않음
   Static 블록에서 사용할 수 있는 속성, 메서드 = static 멤버만(객체 멤버는 클래스가 static 영역에 자리 잡은 후에 생성자를 통해 힙에 생성 -> 클래스의 static 블록이 실행되고 있을 때는 해당 클래스의 객체는 하나도 존재 X => static 블록에서는 객체 멤버에 접근할 수 X) \*인스턴스 블록도 존재. 인스턴스가 생성될 때 마다 {}블록 실행(객체 생성자 실행 되기 전에 먼저 실행)

해당 패키지 or 클래스가 처음으로 사용될 때, 클래스의 정적 속성에 접근(사용), 클래스의 정적 메서드를 사용할 때 -> static 블록 단 한번만 실행(인스턴스(객체)를 여러개 만들어도) = static 영역도 메모리(최대한 늦게 사용을 시작하고 최대한 빨리 반환하는 것이 정석, static 영역에 한번 올라가면 프로그램 종료 전까지 해당 메모리 반환X but, 최대한 늦게 로딩 -> 메모리 사용을 최대한 늦춤)이기 때문

<final>
final = 마지막, 최종 -> 클래, 변수, 메서드에서 사용 가능(객체지향 언어의 구성 요소)
1. final + 클래스 = 상속을 허락하지 않음 = 하위 클래스를 만들 수 없음
2. final + 변수 = 변경 불가능한 상수가 됨 - 정적 상수 선언 시 or 정적 생성자에 해당하는 static 블록 내부에서 초기화 가능(최초 한 번만)
객체 상수 선언 시 or 객체 생성자 or 인스턴스 블록에서 초기화 O(다른 언어의 const 키워드. Java는 const 사용 불가)
3. final + method = 최종 메서드 = 오버라이딩 금지

<instanceof>
인스턴스 = 클래스를 통해서 만들어진 객체 
instanceof 연산자 = 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자 -> true or false를 return (ex. 객체참조변수 instanceof 클래스명)
객체 참조 변수 타입이 아닌 실제 객체 타입에 의해 처리하여 결과가 반환됨(LSP-리스코프 치환 원칙을 어기는 코드일 수 있으므로 리팩터링의 대상이 아닌지 점검 필요)
인터페이스 구현 관계에서도 동일하게 적용 O

<package>
package 키워드 = 네임스페이스(이름공간) 만들어주는 역할. 서로 다른 package에서 동일한 클래스 이름 -> pakagename1.클래스 , packagename2.클래스로 충돌 피할 수 있음(ex. 스마트폰이라는 소유자의 소유자(패키지)가 다름

<this>
this 키워드 = 자기 자신 지칭
지역변수와 속성(객체변수, 정적변수)의 이름이 같으면 -> 지역변수 우선
객체 변수와 이름이 같은 지역 변수가 있는 경우, 객체 변수 사용 시 -> this를 접두사로 사용
정적 변수와 이름이 같은 지역변수가 있는 경우, 정적 변수 사용 시 -> 클래스명을 접두사로 사용 
<super>
super 키워드 = 바로 위 상위 클래스의 인스턴스 지칭(자바는 당일 산속만 지원. super를 접두사로 사용 -> 상위 클래스의 메서드 호출 O)
단, super.super 형태 X(상위의 상위 인스턴스 접근 X)

객체 메서드 호출 시 객체명.객체메서드명() 이 아님 -> 클래스명.객체메서드명()임 -> 객체 멤버 메서드는 각 객체별로 달라지는 것이 아님. 객체 멤버 메서드에서 사용하는 객체 멤버 속성의 값만 다를 뿐임. -> JVM은 지능적으로 객체 멤버 메서드를 스태틱 영역에 단 하나 보유 -> 메서드를 호출할 때 객체 자신을 나타내는 this 객체 참조 변서를 넘김 ex) 뽀로로.tset(); -> 펭귄.test(뽀로로);

<불변 객체(Immutable object)> by final 키워드
불변객체 = 생성 수 그 상태를 바꿀 수 없는 객체 <-> 가변 객체
객체 전체 or 일부 속성만 or 내부에서 사용하는 속성 변화해도 외부에서 상태 변하지 않은 것 = 재할당 O but, 한 번 할당하면 내부 데이터를 변경할 수 없는 객체 ex)string, integer, boolean(값 변경이 아니라 새로운 객체를 만들고 참조하게 하는 것임)
불변 객체 사용 -> 복제, 비교를 위한 조작 단순화 + 성능 개선 but, 객체가 변경 가능한 데이터를 많이 가지고 있으면 오히려 부적절

장점 : 객체 신뢰도 상승, 생성자 및 접근 메소드에 대한 방어 복사 필요 X, 멀티스레드 환경에서 동기화 처리 없이 객체 공유 O
단점 : 객체가 가지는 값마다 새로운 객체 필요 -> 메모리 누수, 성능저하(새로운 객체를 계속 생성해야해서)

선택 과제
static으로 선언한 변수의 초기화 시점 = 인스턴스의 생성과 상관 없이 초기화되는 변수 -> JVM이 실행과정 중 초기화 단계에서 static field들을 설정된 값으로 초기화함(일반적인 인스턴스 변수들과 다름)

Class load 과정 -> Loading(클래스 파일을 가져와서 JVM 메모리에 로드) -> Linking { Verifying(클래스 로드 전 과정 중 가장 복잡하고 시간이 많이 걸림. 읽어들인 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 구성되어있는지 검사) -> Preparing(클래스가 필요로 하는 메모리 할당 - 클래스에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조 등등) -> Resolving(분석. 클래스의 상수 풀 내 모든 symbolic 레퍼런스 -> 다이렉트 레퍼런스로 변경) } -> Initializing(클래스 변수들을 적절한 값으러 초기화, static field들을 설정된 값으로 초기화)

reference link : https://steady-snail.tistory
