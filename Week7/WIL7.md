WIL7

좋은 소프트웨어 설계 = 결합도는 낮추고 응집도는 높이는 것 -> 바람직함
결합도 = 모듈(클래스)간의 상호 의존 정도. 결합도가 낮으면 모듈 간의 상호 의존성 줄어듦 -> 객체의 재사용, 수정, 유지보수 용이 (데이터, 스탬프, 컨트롤, 외부, 공유, 내용 결합도)
응집도 = 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성. 응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아짐 -> 재사용, 기능의 수정, 유지보수가 용이(기능, 순차, 통신, 절차, 시간, 논리, 우연 응집도)

객체 지향 언어를 이용해 객체 지향  프로그램을 올바르게 설계해 나가는 방법이자 5원칙 = SOLID (응집도는 높이고 결합도는 낮추라는 것을 객체 지향 관점에서 재정립 한 것)

SOLID = 객체 지향 프로그램을 구성하는 속성, 메서드, 객체, 패키지, 모듈, 라이브러리, 프레임웤, 아키텍처 등 다양한 곳에 다양하게 적용됨 -> 관점에 따라 다르게 해석될 수 O

SOLID는 이해하기 쉽고, 리팩터링과 유지보수가 수월한 뿐만 아니라 논리적으로 정연한 소프트웨어를 만들기 위해 소프트웨어에 녹여내야 하는 개념이다. (\*참고 내용 : 클린 소프트웨어 part 2 애자일 부분, UML 실전에서는 이것만 쓴다 6장, ZDnet 객체지향 SW 설계의 원칙 기사 -> 책에 있는 페이지들 참고 하기)

-SRP(Single Responsibility Principle) : 단일 책임 원칙 = 어떤 클래스를 변경해야하는 이유는 오직 하나뿐이여야 한다 = 역할(책임)을 분리하라

예를 들어, 남자라는 클래스가 남자친구 역할, 아들 역할, 사원 역할, 소대원 역할을 전부 하도록 설계하는 것이 아닌 역할과 책임에 따라 네 개의 클래스로 쪼개는 것이다. 남자친구 역할을 하는 클래스, 사원 역할을 하는 클래스, 소대원 역할을 하는 클래스, 아들 역할을 하는 클래스로 나누면, 역할과 클래스 명도 딱 떨어지니 이해하기도 좋다. 단일 책임 원칙은 속성, 메서드, 패키지, 모듈, 컴포넌트, 프레임워크 등에도 적용할 수 있다.

\*잘못된 경우의 예시
객체 지향 세계에서 남자는 반드시 군대를 가고, 여자는 절대 군대를 가지 않는다고 가정 -> 만약 사람 클래스에 군번 속성이 있다면? -> 여자도 군번을 가질 수 있음 => 사람 클래스를 남자 클래스, 여자 클래스로 분할하고 남자 클래스에만 군번 속성을 갖게 하면 됨(SRP, 단일 책임 원칙 적용) + 남자 클래스와 여자 클래스에 공통점이 없으면 사람 클래스 삭제 or 공통점이 많다면 사람 클래스를 상위 클래스로 하여 공통점을 사람클래스에 두고 남자 클래스와 여자 클래스는 사람 클래스를 상속(확장)하고 차이점만 각자 구현

하나의 속성이 여러 의미를 갖는 경우 = 단일 책임 원칙을 지키지 못한 경우 -> 데이터베이스 테이블을 설계할 때에도 단일 책임 원칙을 고려해야함 -> 정규화라는 과정을 거침(개념을 확장하면 테이블과 필드에 대한 단일 책임 원칙의 적용임)

\*메서드가 SRP를 지키지 못하는 경우의 예시
강아지 클래스 + 소변보다() 메서드를 구현했다고 가정 -> 수컷이냐 암컷이냐에 따라 소변보다() 메서드에서 분기 처리가 진행된다고 하면 강아지 클래스의 소변보다() 메서드가 가 수컷, 암컷 행위 모두 구현하려고 하는 것이므로 SRP(단일 책임 원칙) 위배하는 것 -> 수컷 강아지와 암컷 강아지 클래스를 따로 구현하고 소변보다() 메서드를 각각 클래스에서 구현함으로써  SRP 원칙을 지킬 수 있다.
=> 단일 책임 원칙을 지키지 않는 대표적인 경우 = 분기 처리를 위한 if문(요즘은 현실에서도 슈퍼맨 같은 사람 보다 각 분야별 전문가를 선호하는 추세이다.)

-OCP(Open Closed Principle) : 개방 폐쇄 원칙 = 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만, 변경에 대해서는 닫혀 있어야한다. = 자신의 확장은 열려있고, 주변의 변화에 대해서는 닫혀 있어야 한다.

\*예시
운전자가 차량을 바꿨다고 해서 운전자가 운전에 영향을 받아야 하는가? -> 객체 지향 세계에서는 해법이 있음 -> 상위 클래스 또는 인터페이스를 중간에 둠 -> 자동차가 생긴다고 해도 객체 지향 세계의 운전자는 운전 습관에 영향을 받지 X -> 다양한 자동차가 생기는 것 = 자동자 입장에서는 자신의 확장에는 개방되어있는 것, 운전자 입장에서는 줍변의 변화에 폐쇄되어 있는 것

\*예시 : 데이터베이스 프로그래밍의 JDBC
JDBC를 사용하는 클라이언트 = DB가 오라클 -> MySQL 바뀌더라도 Connection 설정 부분 외에 따로 수정할 필요 X

Connection 설정 부분을 별도의 설정 파일로 분리 -> 클라이언트 코드 단 한 줄도 변경할 필요 X

JDBC, iBatis, MyBatis, 하이버네이트 등등 DB 프로그래밍 지원하는 라이브러리와 프레임 워크에서도 개방 폐쇄 원칙(OCP)의 예를 찾을 수 있음

오라클 -> MySQL or MS-SQL 교체 시, 자바 애플리케이션은 JDBC 인터페이스(완충 장치)로 인하여 변화에 영향을 받지 X = 자바 애플리케이션은 DB라고 하는 주변의 변화에 닫혀있는 것
DB를 교체한다는 것 = DB가 자신의 확장에는 열려 있다는 것

\*자바에도 개방 폐쇄 원칙(OCP)이 적용
자바 개발자 = 작성하고 있는 소스 코드가 윈도우에서 구동될지, 리눅스에서 구동될지, 다른 운영체제 상에서 구동될 지 걱정 안함 -> JVM과 목적파일(.class)이 있기 때문에 개발자는 다양한 구동 환경에 대해서는 걱정 X, 본인이 작업하고 있는 개발 PC에 설치된 JVM에서 구동되는 코드만 작성하면 됨 => 소스코드는 운영체제의 변화에 닫혀있고, 각 운영체제별 JVM은 확장에 열려 있는 구조 + 개발자의 소스코드 - 목적 파일 - 운영체제별 JVM 에서 목적 파일이 완충 장치의 역할을 해줌

\*편의점 예시
일일 삼교대, 주말에는 다른 아르바이트 직원 but, 직원이 바뀐다고 해서 손님이 구매라는 행위를 하는 데는 영향 X
직원 중 한명은 구매 담당자, 보안 담당자 등 역할이 나뉠 수 있음 but, 근본적으로 판매라는 행위, 손님과의 인터페이스가 바뀌지 않는 한 손님의 구매라는 행위는 직원이 세부적으로 나뉘더라도 바뀌지 않고 영향을 받지 않음
직원 교대 = 주변의 변화 -> 손님의 구매 행위에는 영향 X
직원 = 교대 = 확장 행위에 열려있음

- 구매 담당자의 행위 추가, 보안 담당자의 행위 추가 가능 -> 확장에 대해 직원은 열려 있음

\*스프링 프레임워크도 예시가 될 수 있음

개방폐쇄 원칙을 따르지 않는다고 객체 지향 프로그램 구현하는 것이 불가능하지 X. but, 무시하고 프로그램 작성 시 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 X -> 반드시 OCP를 지켜야함

-LSP(Liskov Substitution Principle) : 리스코프 치환 원칙 = 서브타입은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다 = 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다. = 분류도가 되어야한다 = 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 됨

-상속(확장)은 분류도가 되어야 함 (하위 클래스 is kind of 상위 클래스, 구현 클래스 is able to 인터페이스) = 리스코프 치환 법칙(LSP)을 잘 지키고 있는 것

- AutoCloseable, Appendable, Cloneable, Runnable

\*예시
동물 뽀로로 = new 펭귄(); // 펭귄 한마리가 태어나 뽀로로라 이름을 짓고, 동물의 행위(메서드)를 하게 됨
-> 동물 - 펭귄 구조(분류도)는 리스코프 치환 법칙(LSP)를 만족하는 것

- 하위형에서 선행 조건은 강화될 수 없다
- 하위형에서 후행 조건은 약화될 수 없다
- 하위형에서 상위형의 불변 조건은 반드시 유지돼야 한다.

-ISP(Interface Segregation Principle) : 인터페이스 분리 원칙 = 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다

\*남자 - 남자친구, 아들, 소대원, 사원 역할 예시
단일 책임 원칙(SRP) -> 남자 클래스를 토막내서 하나의 역할(책임)만을 다하는 다수의 클래스로 분할 -> 단일 책임 원칙(SRP)를 대체할 선택 -> 인터페이스 분할 원칙(ISP)
인터페이스 분할 원칙(ISP) -> 남자 클래스를 다중인격화 -> 여자친구를 만날 때는 남자친구 역할만 할 수 있게 인터페이스 제한, 어머니와 함께 있을 때는 아들 인터페이스 제한, .... = 인터페이스 분할 원칙(ISP)의 핵심

같은 문제에 대한 두가지 다른 해결책 - 단일 책임 원칙(SRP), 인터페이스 분할 원칙(ISP) -> 프로젝트 요구 사항, 설계자의 취향에 따라 선택 (일반적으로는 단일 책임 원칙(SRP) 적용하는 것이 더 좋음)

인터페이스 최소주의 원칙 (인터페이스 분할 원칙을 이야기할때 항상 함께 등장함)= 인터페이스를 통해 메서드를 외부에 제공할 때는 최소한의 메서드만 제공하라
예시에 적용 -> 남자친구 인터페이스에 사격하기() 메서드 제공할 필요 X -> 상위 클래스는 풍성할수록 좋고, 인터페이스는 작을 수록 좋다(리스코프 치환 원칙(LSP)에 의해 하위 객체는 상위 객체인 척 할 수 O) = 상위 클래스가 하위 클래스들의 공통으로 가질 수 있는 속성과 메서드를 상속해주는 것

빈약한 상위 클래스 이용 -> 여기저기 형 변환 발생  + 상속의 혜택 제대로 누리지 X (객체 참조 변수를 하위 클래스로 할 수 있지만, 그러면 굳이 상속 구조 만들 필요 X)
풍성한 상위 클래스 이용 -> 사용불가능 한 경우나 불필요한 형변환이 없음
소개하다() 메서드의 경우, 상위 클래스인 사람 클래스에 정의됨 -> 소개 내용은 다르지만, 소개하다라는 기능은 둘 다 필요하기 때문 => 추상 메서드 사용

\*인터페이스 최소주의의 장점 예시
새로 부임한 소대장님 = 여자, 소대장님이 남자 객체의 여자친구가 됨 -> 소대원 남자친구 인터페이스 작성 -> 남자는 훈련 중에는 소대원으로서의 역할만, 데이트 중에는 남자친구로서의 역할만을 충실하게 수행해야함 => 객체 지향에서도 동일한 원리 적용 -> 인터페이스는 그 역할에 충실한 최소한 기능만 공개하라 -> 인터페이스 = is able to라는 기준으로 만들어야함

-DIP(Dependency Inversion Principle) : 의존 역전 원칙 = 자신보다 변하기 쉬운 것에 의존하지 마라 = 상위 클래스, 인터페이스, 추상클래스를 통해 의존하라(하위 클래스나 구체 클래스에 비해 변하지 않을 가능성이 높음)

- 고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야한다.
- 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다.
- 자주 변경 되는 구체(Concrete) 클래스에 의존하지 마라

\*자동차 예시
자동차 -> 타이어(인터페이스) - 스노우 타이어, 일반 타이어, 광폭 타이어 등등
자동차가 구체적인 타이어들이 아닌 추상화된 타이어 인터페이스에만 의존하게 함 => 스노우 타이어 -> 일반 타이어 or 구체적인 타이어로 변경되어도 자동차는 그 영향을 받지 X (개방 폐쇄 원칙(OCP)와 비슷)
기존에는 스노우 타이어가 무엇도 의존하지 않는 클래스 였음 -> 추상적인 것(타이어 인터페이스)에 의존하게 됨 = 의존의 방향 역전
자동차는 자신보다 변하기 쉬운 스노우 타이어에 의존하던 관계 -> 중간에 추상화된 타이어 인터페이스를 추가 + 의존 관계 역전
의존 역전 원칙(DIP) = 자신보다 변하기 쉬운 것에 의존하던 것 -> 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향을 받지 않게 하는 것

디자인 패턴, 설계 원칙 모두 결국 객체 지향 4대 특성을 활용한 것임 -> 상속과 다형성이니 결국 비슷한 모습의 코드로 구현됨

\*JDBC에서도 확인할 수 있음

-정리
SOLID = 객체 지향을 올바르게 프로그램에 녹여내기 위한 원칙 = 객체 지향 4대 특성을 제대로 활용한 결과로 당연히 나타나는 것 => 객체 지향 4대 특성을 제대로 이해 -> SOLID 제대로 이해 및 활용 O

-SoC (Separation Of Concerns) : 관심사의 분리 = 관심있는 것 끼리는 하나의 객체 안으로 또는 친한 객체로 모음, 관심이 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리. = 하나의 속성, 하나의 메서드, 하나의 클래스, 하나의 모듈, 또는 하나의 패키지에는 하나의 관심사만 들어 있어야 한다 + 관심사가 다르고 변화의 시기가 다르면 분리해야한다

Soc 적용(스프링도 적용) -> 자연스럽게 단일 책임 원칙(SRP), 인터페이스 분리 원칙(ISP), 개방 폐쇄 원칙(OCP)에 도달함

-SOLID
SRP(단일 책임 원칙) = 어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이다.
OCP(개방 폐쇄 원칙) = 자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
LSP(리스코프 치환 원칙) = 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
ISP(인터페이스 분리 원칙) = 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.
DIP(의존 역전 원칙) = 자신보다 변하기 쉬운 것에 의존하지 마라

SOLID 원칙 적용 -> 소스파일의 개수 더 많아지는 경향 있음
하지만, 많아진 파일이 논리를 더욱 잘 분할하고, 잘 표현함 -> 이해하기 쉽고 개발하기 쉬움, 유지와 관리, 보수하기 쉬운 소스를 만들 수 있음 (소스 파일 개수 부담은 감수하고도 남는다.)

객체 지향 = 현실 세계를 모델링 -> 객체 지향 세계는 현실 세계같아야함 + 모델링을 통해 추상화 됨(SOLID)
